<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInite0fb3a6179bd2adfab34d26f07d2cd46
{
    /**
     * 静态对象类型变量，类似单例模式的只有一个对象，防止二次实例化
     */
    private static $loader;

    /**
     * 先有鸡后有蛋，想自动加载其它类，先自动加载自己吧
     */
    public static function loadClassLoader($class)
    {
        // (4) $class 形参就是代表 PHP 没有载入的类全名（包含命名空间，且开头的 \ 去掉）
        if ('Composer\Autoload\ClassLoader' === $class) {
            // (5) 载入
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        // (1) 类似单例模式的操作
        if (null !== self::$loader) {
            return self::$loader;
        }
        // (2) 将 loadClassLoader 静态方法添加至 PHP 自动加载队列
        spl_autoload_register(array('ComposerAutoloaderInite0fb3a6179bd2adfab34d26f07d2cd46', 'loadClassLoader'), true, true);

        // (3) PHP没有载入 Composer\Autoload\ClassLoader 类，去找 PHP 自动加载队列，并执行里面的 loadClassLoader，
        //然后载入 Composer\Autoload\ClassLoader 类，成功 new 一个对象。
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        // (6) 将 loadClassLoader 静态方法从 PHP 自动加载队列中删除
        spl_autoload_unregister(array('ComposerAutoloaderInite0fb3a6179bd2adfab34d26f07d2cd46', 'loadClassLoader'));

        /*
         * (7)
         *
         * 第一个表达式 PHP_VERSION_ID >= 50600: 由于我用的是 PHP7.2 故，此表达式是 true，与运算未短路，执行下一表达式
         * 第二个表达式 !defined('HHVM_VERSION'): 没有用 HHVM 虚拟机则返回 true，我的确没用，未短路，继续下一个表达式
         * 第三个表达式 (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()) 分解如下:
         * 第三个表达式中第一个表达式 !function_exists('zend_loader_file_encoded'): 如果不存在 zend_loader_file_encoded 函数返回 true。经过测试我 PHP 中的确没有 zend_loader_file_encoded 函数，故与第三表达式中第二表达式短路。
         * 整体返回 true
         */
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());

        if ($useStaticLoader) {
            // (8) 加载 vendor\composer\autoload_static.php 静态的自动加载映射类
            require_once __DIR__ . '/autoload_static.php';
// (9) 调用静态自动加载映射类的 getInitializer 方法，此方法将返回一个闭包，再通过执行此闭包，将自动加载映射规则注入到 loader 对象中
            call_user_func(\Composer\Autoload\ComposerStaticInite0fb3a6179bd2adfab34d26f07d2cd46::getInitializer($loader));
        } else {
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }
// (10) 调用 loader 对象的 register 方法，把 loadClass 方法添加到 PHP 自动加载队列中
        $loader->register(true);

        if ($useStaticLoader) {
            // (11) 返回 Laravel 全局函数文件的绝对路径，准备加载全局函数
            $includeFiles = Composer\Autoload\ComposerStaticInite0fb3a6179bd2adfab34d26f07d2cd46::$files;
        } else {
            $includeFiles = require __DIR__ . '/autoload_files.php';
        }
        foreach ($includeFiles as $fileIdentifier => $file) {
            // (12) 取全局函数 文件标识码 和 文件绝对路径 执行循环加载
            composerRequiree0fb3a6179bd2adfab34d26f07d2cd46($fileIdentifier, $file);
        }

        return $loader;
    }
}
// (13) 根据全局函数 文件标识码 查看是否加载过，防止二次加载
function composerRequiree0fb3a6179bd2adfab34d26f07d2cd46($fileIdentifier, $file)
{
    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        // (14) 执行全局函数加载
        require $file;
// (15) 转换全局函数加载状态，防止二次加载
        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    }
}
